  
  [1X1 [33X[0;0YIntroduction[133X[101X
  
  
  [1X1.1 [33X[0;0YOverview[133X[101X
  
  [33X[0;0YThis   package   is   about   wreath   product  elements  in  their  general
  representation.  This  representation  is  more  intuitive  to the User when
  working  with  wreath  products  and  additionally  may  have  computational
  benefits over other representations.[133X
  
  [33X[0;0Y[TODO:: Add references][133X
  
  
  [1X1.2 [33X[0;0YNotation[133X[101X
  
  [33X[0;0YLet  [22XG = K â‰€ H[122X be a wreath product, where [22XH[122X is a permutation group of degree
  [22Xm[122X.  The  wreath product is defined as the semidirect product of the function
  space [22XK^m[122X with [22XH[122X, where [22XÏ€ âˆˆ H[122X acts on [22Xf âˆˆ K^m[122X by setting [22Xf^{Ï€} : {1, ..., m}
  â†’ K, i â†¦ [(i)Ï€^{-1}]f[122X.[133X
  
  [33X[0;0YFormally we can write elements of [22XG[122X as a tuple [22Xg = (f, Ï€) âˆˆ G[122X, where [22Xf âˆˆ K^m[122X
  is  a  function [22Xf : {1, ..., m} â†’ K[122X and [22XÏ€ âˆˆ H â‰¤ Sym(m)[122X is a permutation on [22Xm[122X
  points. We call [22Xf[122X the [13Xbase component[113X and [22XÏ€[122X the [13Xtop component[113X of [22Xg[122X.[133X
  
  [33X[0;0YWe  can naturally identify a map [22Xf âˆˆ K^m[122X with a tuple [22X(g_1, ..., g_m)[122X, where
  each  [22Xg_i  âˆˆ K[122X is the image of [22Xi âˆˆ {1, ..., m}[122X under [22Xf[122X. This yields a second
  useful  notation  for  elements in [22XG[122X by writing [22Xg = (g_1, ..., g_m; Ï€)[122X. Note
  that  we  use  a  semicolon  to  seperate  the  base  component from the top
  component. Further we call the element [22Xg_i[122X the [13X[22Xi[122X-th base component[113X of [22Xg[122X.[133X
  
  
  [1X1.3 [33X[0;0YWreath Cycle Decomposition[133X[101X
  
  [33X[0;0YIn   a  permutation  group  we  have  the  well-known  concept  of  a  cycle
  decomposition.  For  wreath products we have a similar concept called [13Xwreath
  cycle decomposition[113X that allows us to solve certain computational tasks more
  efficiently.  First we introduce the concept of the territory. We define the
  [13Xterritory[113X  of  an element [22Xg = (g_1, ..., g_m; Ï€) âˆˆ G[122X by [22Xterr(g) := supp(Ï€) âˆª
  {i : g_i â‰  1}[122X.[133X
  
  [33X[0;0YAn  element  [22Xg = (g_1, ..., g_m; Ï€) âˆˆ G[122X is called a [13Xwreath cycle[113X if either [22XÏ€[122X
  is a cycle and [22Xg_i = 1[122X for all [22Xi âˆˆ fix(Ï€)[122X or [22X|terr(g)| = 1[122X.[133X
  
  [33X[0;0YThe idea is to write an arbitrary element of the wreath product [22XG = K â‰€ H[122X as
  a product of disjoint wreath cycles as follows:[133X
  
  [33X[0;0YDecompose  [22XÏ€[122X  into cycles, say [22XÏ€ = Ï€_1 ... Ï€_l[122X. For a set [22XI â‰¤ {1, ..., m}[122X we
  define [22Xf_I[122X as an element of [22XK^m[122X by setting[133X
  
  [30X    [33X[0;6Y[22X[i]f_I := g_i[122X, if [22Xi âˆˆ I[122X[133X
  
  [30X    [33X[0;6Y[22X[i]f_I := 1_K[122X, else[133X
  
  [33X[0;0YFor each cycle [22XÏ€_r[122X we define [22Xtop_r := (f_{supp(Ï€_r)}, Ï€_r)[122X. For each point [22Xi[122X
  such  that  [22Xi  not âˆˆ supp(Ï€)[122X and [22Xg_i â‰  1_K[122X we define [22Xbase_i := (f_{i}, 1_H)[122X.
  Then  [22Xg[122X can be written as a product of the [22Xtop_r[122X and [22Xbase_i[122X elements and all
  those  element  are  wreath cycles with pairwise disjoint territory. Thus in
  particular these elements commute pairwise.[133X
  
  
  [1X1.4 [33X[0;0YSparse Wreath Cycle Decomposition[133X[101X
  
  [33X[0;0YThe  main  motivation  for  introducing  the concept of [13Xsparse wreath cycles
  decompositions[113X  is  the  efficient  computation  of  centralisers  of wreath
  product  elements.  Simply  put,  we compute the centraliser of an arbitrary
  element  [22Xg âˆˆ G[122X in [22XG[122X by conjugating it to a restricted representative [22Xh = g^c
  âˆˆ G[122X and computing the centraliser of [22Xh[122X in [22XG[122X.[133X
  
  [33X[0;0YWe  say  that  a  wreath cycle [22Xg = (g_1, ..., g_m; Ï€) âˆˆ G[122X is a [13Xsparse wreath
  cycle[113X, if there exists an [22Xi_0[122X such that [22Xg_i â‰  1[122X for all [22Xi â‰  i_0[122X.[133X
  
  [33X[0;0YWe   call   a  product  of  sparse  wreath  cycles  a  [13Xsparse  wreath  cycle
  decomposition[113X. Every element [22Xg âˆˆ G[122X can be conjugated by a base group element
  [22Xc  âˆˆ  G[122X to an element [22Xh = g^c âˆˆ G[122X that can be written in sparse wreath cycle
  decomposition as follows:[133X
  
  [33X[0;0YSuppose for an arbitrary element [22Xg = (g_1, ..., g_m; Ï€) âˆˆ G[122X we have a wreath
  cycle  decomposition  into  cycles  [22Xw_1,  ..., w_l âˆˆ G[122X. There exist pairwise
  disjoint  base  group  elements  [22Xc_1,  ..., c_l âˆˆ G[122X such that [22Xw_k^{c_k}[122X is a
  sparse  wreath  cycle  for  all  [22Xk[122X.  In particular the product of the sparse
  wreath  cycles  is  the  same  as [22Xg^{c_1 â‹¯ c_l}[122X and the elements [22Xc_k[122X commute
  pairwise.[133X
  
  
  [1X1.5 [33X[0;0YExample[133X[101X
  
  [33X[0;0YIn this section we present an example session.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage("WPE");;[127X[104X
    [4X[28X[128X[104X
    [4X[28X# Construct an imprimitive wreath product[128X[104X
    [4X[28X# that is embedded into a symmetric group.[128X[104X
    [4X[28X# This is the native GAP wreath product command.[128X[104X
    [4X[25Xgap>[125X [27XK := AlternatingGroup(5);;[127X[104X
    [4X[25Xgap>[125X [27XH := SymmetricGroup(7);;[127X[104X
    [4X[25Xgap>[125X [27XG := WreathProduct(K, H);[127X[104X
    [4X[28X<permutation group of size 14108774400000000 with 4 generators>[128X[104X
    [4X[28X[128X[104X
    [4X[28X# Construct an isomorphism to the generic wreath product[128X[104X
    [4X[28X# that is provided in this package.[128X[104X
    [4X[25Xgap>[125X [27Xiso := IsomorphismToGenericWreathProduct(G);;[127X[104X
    [4X[25Xgap>[125X [27XW := Image(iso);[127X[104X
    [4X[28X<group of size 14108774400000000 with 4 generators>[128X[104X
    [4X[28X[128X[104X
    [4X[28X# Let us compare how GAP displays elements in G and W respectively.[128X[104X
    [4X[28X# Elements in G are represented as permutations.[128X[104X
    [4X[28X# In this representation it is completely unclear[128X[104X
    [4X[28X# how the base and top components of this element look like.[128X[104X
    [4X[25Xgap>[125X [27Xg := (1,23,33,27,9,13,2,25,34,28,8,14,3,24,35,30,10,12,5,21,32,29,6,11,[127X[104X
    [4X[25X>[125X [27X4,22,31,26,7,15)(18,19,20);;[127X[104X
    [4X[25Xgap>[125X [27Xg in G;[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[28X[128X[104X
    [4X[28X# Elements in W are represented as generic wreath product elements[128X[104X
    [4X[28X# that makes it easy to read off the base and top component of the element.[128X[104X
    [4X[25Xgap>[125X [27Xx := g^iso;[127X[104X
    [4X[28X( (1,3,4,2,5), (2,5)(3,4), (1,4,3,2,5), (3,4,5), (1,2)(4,5), (1,2,4), [128X[104X
    [4X[28X(2,4,3); (1,5,7,6,2,3) )[128X[104X
    [4X[28X[128X[104X
    [4X[28X# We can display each component easily with the provided commands.[128X[104X
    [4X[25Xgap>[125X [27XBaseComponentOfWreathProductElement(x, 2);[127X[104X
    [4X[28X(2,5)(3,4)[128X[104X
    [4X[25Xgap>[125X [27XTopComponentOfWreathProductElement(x);[127X[104X
    [4X[28X(1,5,7,6,2,3)[128X[104X
    [4X[28X[128X[104X
    [4X[28X# Let us decompose the element into disjoint wreath cycles.[128X[104X
    [4X[25Xgap>[125X [27XwreathDecomp := WreathCycleDecomposition(x);[127X[104X
    [4X[28X[ ( (), (), (), (3,4,5), (), (), (); () ), [128X[104X
    [4X[28X  ( (1,3,4,2,5), (2,5)(3,4), (1,4,3,2,5), (), (1,2)(4,5), (1,2,4), (2,4,3); [128X[104X
    [4X[28X    (1,5,7,6,2,3) ) ][128X[104X
    [4X[28X[128X[104X
    [4X[28X# Now we want to bring these cycles into sparse form.[128X[104X
    [4X[28X# Each sparse wreath cycle is a very restricted element,[128X[104X
    [4X[28X# since at most one entry in the base component is non-trivial.[128X[104X
    [4X[28X# The product of these elements is a conjugate to x.[128X[104X
    [4X[25Xgap>[125X [27XsparseDecomp := SparseWreathCycleDecomposition(x);[127X[104X
    [4X[28X[ ( (), (), (), (3,4,5), (), (), (); () ), [128X[104X
    [4X[28X  ( (1,2,3,5,4), (), (), (), (), (), (); (1,5,7,6,2,3) ) ][128X[104X
    [4X[28X[128X[104X
    [4X[28X# We can also compute the conjugating elements to switch between[128X[104X
    [4X[28X# the wreath cycles and sparse wreath cycles.[128X[104X
    [4X[28X# The product of these elements conjugates the wreath cycles[128X[104X
    [4X[28X# simultaneously to the sparse wreath cycles.[128X[104X
    [4X[25Xgap>[125X [27Xconj := ConjugatorWreathCycleToSparse(x);[127X[104X
    [4X[28X[ ( (), (), (), (), (), (), (); () ), ( (), (1,4,2), (1,4,3,2,5), (), [128X[104X
    [4X[28X    (1,4,5,3,2), (), (2,4,3); () ) ][128X[104X
    [4X[25Xgap>[125X [27XwreathDecomp[1]^conj[1] = sparseDecomp[1];[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XwreathDecomp[2]^conj[2] = sparseDecomp[2];[127X[104X
    [4X[28Xtrue[128X[104X
  [4X[32X[104X
  
