<!--
This chapter gives a short introduction and explains the notation
behind the package.
-->

<Chapter Label="Introduction">
<Heading>Introduction</Heading>

<Section Label="Intro Overview">
<Heading>Overview</Heading>

This package is about wreath product elements in their general representation.
This representation is more intuitive to the User when working with wreath products
and additionally may have computational benefits over other representations. <P/>

[TODO:: Add references]

</Section>

<Section Label="Intro Notation">
<Heading>Notation</Heading>

Let <M>G = K \wr H</M> be a wreath product,
where <M>H</M> is a permutation group of degree <M>m</M>.
The wreath product is defined as the semidirect product
of the function space <M>K^m</M> with <M>H</M>,
where <M>\pi \in H</M> acts on <M>f \in K^m</M>
by setting <M>f^{{\pi}} : \{1, \ldots, m\} \rightarrow K, i \mapsto [(i)\pi^{{-1}}]f</M>. <P/>

Formally we can write elements of <M>G</M> as a tuple <M>g = (f, \pi) \in G</M>,
where <M>f \in K^m </M> is a function <M>f : \{1, \ldots, m\} \rightarrow K </M>
and <M>\pi \in H \leq Sym(m)</M> is a permutation on <M>m</M> points.
We call <M>f</M> the <E>base component</E> and <M>\pi</M> the <E>top component</E> of <M>g</M>. <P/>

We can naturally identify a map <M>f \in K^m</M> with a tuple <M>(g_1, \ldots, g_m)</M>,
where each <M>g_i \in K</M> is the image of <M>i \in \{1, \ldots, m\}</M> under <M>f</M>.
This yields a second useful notation for elements in <M>G</M> by writing
<M>g = (g_1, \ldots, g_m; \pi)</M>.
Note that we use a semicolon to seperate the base component from the top component.
Further we call the element <M>g_i</M> the <E><M>i</M>-th base component</E> of <M>g</M>.

</Section>

<Section Label="Wreath Cycle">
<Heading>Wreath Cycle Decomposition</Heading>

In a permutation group we have the well-known concept of a cycle decomposition.
For wreath products we have a similar concept called <E>wreath cycle decomposition</E>
that allows us to solve certain computational tasks more efficiently.

First we introduce the concept of the territory.
We define the <E>territory</E> of an element <M>g = (g_1, \ldots, g_m; \pi) \in G</M>
by <M>\textrm{terr}(g) := \textrm{supp}(\pi) \cup \{i : g_i \neq 1\}</M>, 
where <M>\textrm{supp}(\pi)</M> denoted the set of moved points of <M>\pi</M>. <P/>

An element <M>g = (g_1, \ldots, g_m; \pi) \in G</M> is called a <E>wreath cycle</E> if
either <M>\pi</M> is a cycle and <M>g_i = 1</M> for all <M>i \in fix(\pi)</M>
or <M>|\textrm{terr}(g)| = 1</M>. <P/>

In the following we outline a proof how to compute a decomposition of an arbitrary element of the wreath product <M>G = K \wr H</M>
into a product of disjoint wreath cycles: <P/>

Decompose <M>\pi</M> into cycles, say <M>\pi = \pi_1 ... \pi_l</M>.
For a set <M>I \subseteq \{1, \ldots, m\}</M> we define <M>f_I</M>
as an element of <M>K^m</M> by setting
<List>
    <Item> <M>[i]f_I := g_i</M>, if <M>i \in I</M> </Item>
    <Item> <M>[i]f_I := 1_K</M>, else </Item>
</List>
For each cycle <M>\pi_r</M> we define <M>top_r := (f_{{\textrm{supp}(\pi_r)}}, \pi_r)</M>.
For each point <M>i</M> such that <M>i \not \in \textrm{supp}(\pi)</M> and <M>g_i \neq 1_K</M>
we define <M>base_i := (f_{\{i\}}, 1_H)</M>.
Then <M>g</M> can be written as a product of the <M>top_r</M> and <M>base_i</M> elements
and all those element are wreath cycles with pairwise disjoint territory.
Thus in particular these elements commute pairwise. <P/>

</Section>

<Section Label="Sparse Wreath Cycle">
<Heading>Sparse Wreath Cycle Decomposition</Heading>

The main motivation for introducing the concept of <E>sparse wreath cycles decompositions</E>
is the efficient computation of centralisers of wreath product elements.
Simply put, we compute the centraliser of an arbitrary element <M>g \in G</M> in <M>G</M>
by conjugating it to a restricted representative <M>h = g^c \in G</M>
and computing the centraliser of <M>h</M> in <M>G</M>.<P/>

We say that a wreath cycle <M>g = (g_1, \ldots, g_m; \pi) \in G</M> is a <E>sparse wreath cycle</E>,
if there exists an <M>i_0</M> such that <M>g_i = 1</M> for all <M>i \neq i_0</M>.<P/>

We call a product of sparse wreath cycles a <E>sparse wreath cycle decomposition</E>.
Every element <M>g \in G</M> can be conjugated by a base group element <M>c \in G</M>
to an element <M>h = g^c \in G</M> that can be written in sparse wreath cycle decomposition as follows: <P/>

Suppose for an arbitrary element <M>g \in G</M> we have
a wreath cycle decomposition into cycles <M>w_1, \ldots, w_l \in G</M>.
There exist pairwise disjoint base group elements <M>c_1, \ldots, c_l \in G</M>
such that <M>w_k^{{c_k}}</M> is a sparse wreath cycle for all <M>k</M>.
In particular the product of the sparse wreath cycles is the same as <M>g^{{c_1 \cdots c_l}}</M>
and the elements <M>c_k</M> commute pairwise.<P/>

</Section>

<Section Label="Intro Example">
<Heading>Example</Heading>

In this section we present an example session.
<P/>
<Example><![CDATA[
gap> LoadPackage("WPE");;

# Construct an imprimitive wreath product
# that is embedded into a symmetric group.
# This is the native GAP wreath product command.
gap> K := AlternatingGroup(5);;
gap> H := SymmetricGroup(7);;
gap> G := WreathProduct(K, H);
<permutation group of size 14108774400000000 with 4 generators>

# Construct an isomorphism to the generic wreath product
# that is provided in this package.
gap> iso := IsomorphismToGenericWreathProduct(G);;
gap> W := Image(iso);
<group of size 14108774400000000 with 4 generators>

# Let us compare how GAP displays elements in G and W respectively.
# Elements in G are represented as permutations.
# In this representation it is completely unclear
# how the base and top components of this element look like.
gap> g := (1,13,3,14,4,12,2,15,5,11)(6,31,21,7,35,25,9,33,23,8,34,24,10,32,22)(18,19,20);;
gap> g in G;
true

# Elements in W are represented as generic wreath product elements
# that makes it easy to read off the base and top component of the element.
gap> x := g^iso;
( (1,3,4,2,5), (2,5)(3,4), (), (3,4,5), (1,2)(4,5), (), (); (1,3)(2,7,5) )

# We compute the territory of x.
gap> Territory(x);
[ 1, 2, 3, 4, 5, 7 ]

# We can display each component easily with the provided commands.
gap> BaseComponentOfWreathProductElement(x, 2);
(2,5)(3,4)
gap> TopComponentOfWreathProductElement(x);
(1,3)(2,7,5)

# Let us decompose the element into disjoint wreath cycles.
gap> wreathDecomp := WreathCycleDecomposition(x);
[ ( (), (), (), (3,4,5), (), (), (); () ), 
  ( (1,3,4,2,5), (), (), (), (), (), (); (1,3) ), 
  ( (), (2,5)(3,4), (), (), (1,2)(4,5), (), (); (2,7,5) ) ]

# Now we want to bring these cycles into sparse form.
# Each sparse wreath cycle is a very restricted element,
# since at most one entry in the base component is non-trivial.
# The product of these elements is a conjugate to x.
gap> sparseDecomp := SparseWreathCycleDecomposition(x);
[ ( (), (), (), (3,4,5), (), (), (); () ), 
  ( (1,3,4,2,5), (), (), (), (), (), (); (1,3) ), 
  ( (), (1,2,4,3,5), (), (), (), (), (); (2,7,5) ) ]

# We can also compute the conjugating elements to switch between
# the wreath cycles and sparse wreath cycles.
# The product of these elements conjugates the wreath cycles
# simultaneously to the sparse wreath cycles.
gap> conj := ConjugatorWreathCycleToSparse(x);
[ ( (), (), (), (), (), (), (); () ), ( (), (), (), (), (), (), (); () ), 
  ( (), (), (), (), (1,2)(4,5), (), (1,2)(4,5); () ) ]
gap> wreathDecomp[1]^conj[1] = sparseDecomp[1];
true
gap> wreathDecomp[2]^conj[2] = sparseDecomp[2];
true
gap> wreathDecomp[3]^conj[3] = sparseDecomp[3];
true
]]></Example>
<P/>

</Section>

<!-- ############################################################ -->

</Chapter>