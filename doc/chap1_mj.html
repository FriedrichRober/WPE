<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (WPE) - Chapter 1: Introduction</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap1"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap1.html">[MathJax off]</a></p>
<p><a id="X7DFB63A97E67C0A1" name="X7DFB63A97E67C0A1"></a></p>
<div class="ChapSects"><a href="chap1_mj.html#X7DFB63A97E67C0A1">1 <span class="Heading">Introduction</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X8389AD927B74BA4A">1.1 <span class="Heading">Overview</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X7DD31B407B9402A3">1.2 <span class="Heading">Notation</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X867C059E7E460EFA">1.3 <span class="Heading">Wreath Cycle Decomposition</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X7B9157FB8383F109">1.4 <span class="Heading">Sparse Wreath Cycle</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X85861B017AEEC50B">1.5 <span class="Heading">Example</span></a>
</span>
</div>
</div>

<h3>1 <span class="Heading">Introduction</span></h3>

<p>This chapter serves as an introduction and explains the notation of the package <strong class="pkg">WPE</strong>.</p>

<p><a id="X8389AD927B74BA4A" name="X8389AD927B74BA4A"></a></p>

<h4>1.1 <span class="Heading">Overview</span></h4>

<p>The package <strong class="pkg">WPE</strong> is about wreath product elements in their generic representation. This representation is more intuitive to the User when working with wreath products and additionally may have computational benefits over other representations.</p>

<p>In particular this package provides efficient methods for finding conjugating elements, conjugacy classes, and centralisers. The implementations are based on <a href="chapBib_mj.html#biBwpeConjugacy">[BNRW22]</a> and references therein. For a complete list of operations that exploit the generic representation, see Chapter <a href="chap4_mj.html#X7DE8E16C7C2D387B"><span class="RefLink">4</span></a>.</p>

<p>For example, the computation of all <span class="SimpleMath">\(886\,640\)</span> conjugacy classses of the wreath product <span class="SimpleMath">\(W = \textrm{M}_{22} \wr \textrm{A}_9\)</span> takes about 12 seconds with <strong class="pkg">WPE</strong>. With native <strong class="pkg">GAP</strong> this computation is not feasible.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage("WPE");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K := MathieuGroup(22);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := AlternatingGroup(9);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := WreathProduct(K, H);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := ConjugacyClasses(G);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(C);</span>
886640
</pre></div>

<p><a id="X7DD31B407B9402A3" name="X7DD31B407B9402A3"></a></p>

<h4>1.2 <span class="Heading">Notation</span></h4>

<p>Let <span class="SimpleMath">\(G = K \wr H\)</span> be a wreath product, where <span class="SimpleMath">\(H\)</span> is a permutation group of degree <span class="SimpleMath">\(m\)</span>. The wreath product is defined as the semidirect product of the function space <span class="SimpleMath">\(K^m\)</span> with <span class="SimpleMath">\(H\)</span>, where <span class="SimpleMath">\(\pi \in H\)</span> acts on <span class="SimpleMath">\(f \in K^m\)</span> by setting <span class="SimpleMath">\(f^{{\pi}} : \{1, \ldots, m\} \rightarrow K, i \mapsto [(i)\pi^{{-1}}]f\)</span>. We denote the parent wreath product by <span class="SimpleMath">\(P = K \wr \textrm{Sym}(m) \geq G\)</span>.</p>

<p>Formally we can write an element of <span class="SimpleMath">\(G\)</span> as a tuple <span class="SimpleMath">\(g = (f, \pi) \in G\)</span>, where <span class="SimpleMath">\(f \in K^m \)</span> is a function <span class="SimpleMath">\(f : \{1, \ldots, m\} \rightarrow K \)</span> and <span class="SimpleMath">\(\pi \in H \leq \textrm{Sym}(m)\)</span> is a permutation on <span class="SimpleMath">\(m\)</span> points. We call <span class="SimpleMath">\(f\)</span> the <em>base component</em> and <span class="SimpleMath">\(\pi\)</span> the <em>top component</em> of <span class="SimpleMath">\(g\)</span>.</p>

<p>We can naturally identify a map <span class="SimpleMath">\(f \in K^m\)</span> with a tuple <span class="SimpleMath">\((g_1, \ldots, g_m)\)</span>, where each <span class="SimpleMath">\(g_i \in K\)</span> is the image of <span class="SimpleMath">\(i \in \{1, \ldots, m\}\)</span> under <span class="SimpleMath">\(f\)</span>. This yields a second useful notation for elements in <span class="SimpleMath">\(G\)</span> by writing <span class="SimpleMath">\(g = (g_1, \ldots, g_m; \pi)\)</span>. Note that we use a semicolon to seperate the base component from the top component. Further we call the element <span class="SimpleMath">\(g_i\)</span> the <em><span class="SimpleMath">\(i\)</span>-th base component</em> of <span class="SimpleMath">\(g\)</span>.</p>

<p>Analogous, the subgroup <span class="SimpleMath">\(B = K^m \times \langle 1_H \rangle \leq G\)</span> is called the <em>base group</em> of <span class="SimpleMath">\(G\)</span> and the subgroup <span class="SimpleMath">\(T = \langle 1_K \rangle^m \times H \leq G\)</span> is called the <em>top group</em> of <span class="SimpleMath">\(G\)</span>.</p>

<p><a id="X867C059E7E460EFA" name="X867C059E7E460EFA"></a></p>

<h4>1.3 <span class="Heading">Wreath Cycle Decomposition</span></h4>

<p>In a permutation group we have the well-known concept of a cycle decomposition. For wreath products we have a similar concept called <em>wreath cycle decomposition</em> that allows us to solve certain computational tasks more efficiently.</p>

<p>Detailed information on <em>wreath cycle decompositions</em> can be found in Chapter 2 in <a href="chapBib_mj.html#biBwpeConjugacy">[BNRW22]</a>. Chapters 3-5 in <a href="chapBib_mj.html#biBwpeConjugacy">[BNRW22]</a> describe how these can be exploited for finding conjugating elements, conjugacy classes, and centralisers, and Chapter 6 in <a href="chapBib_mj.html#biBwpeConjugacy">[BNRW22]</a> contains a table of timings of sample computations done with <strong class="pkg">WPE</strong> vs. native <strong class="pkg">GAP</strong>.</p>

<p>We use the notation from <a href="chap1_mj.html#X7DD31B407B9402A3"><span class="RefLink">1.2</span></a> in order to introduce the following concepts.</p>

<p><span class="SimpleMath">\(\bf{Definition:}\)</span> We define the <em>territory</em> of an element <span class="SimpleMath">\(g = (g_1, \ldots, g_m; \pi) \in G\)</span> by <span class="SimpleMath">\(\textrm{terr}(g) := \textrm{supp}(\pi) \cup \{i : g_i \neq 1\}\)</span>, where <span class="SimpleMath">\(\textrm{supp}(\pi)\)</span> denotes the set of moved points of <span class="SimpleMath">\(\pi\)</span>.</p>

<p><span class="SimpleMath">\(\bf{Definition:}\)</span> Two elements <span class="SimpleMath">\(g, h \in G\)</span> are said to be <em>disjoint</em> if their territories are disjoint.</p>

<p><span class="SimpleMath">\(\bf{Lemma:}\)</span> Disjoint elements in <span class="SimpleMath">\(G\)</span> commute.</p>

<p><span class="SimpleMath">\(\bf{Definition:}\)</span> An element <span class="SimpleMath">\(g = (g_1, \ldots, g_m; \pi) \in G\)</span> is called a <em>wreath cycle</em> if either <span class="SimpleMath">\(\pi\)</span> is a cycle and <span class="SimpleMath">\(\textrm{terr}(g) = \textrm{supp}(\pi)\)</span>, or <span class="SimpleMath">\(|\textrm{terr}(g)| = 1\)</span>.</p>

<p><span class="SimpleMath">\(\bf{Example:}\)</span> For example if we consider the wreath product <span class="SimpleMath">\( \textrm{Sym}(4) \wr \textrm{Sym}(5) \)</span>, the element</p>

<p class="center">\[
{\bf(} \;\; (),\, (1,2,3),\, (),\, (1,2),\, ();\, (1,2,4) \;\; {\bf)}
\]</p>

<p>is a wreath cycle as described in the first case and the element</p>

<p class="center">\[
{\bf(} \; (),\, (),\, (1,3),\, (),\, ();\, () \;\; {\bf)}
\]</p>

<p>is a wreath cycle as described in the second case. Moreover, these elements are disjoint and thus commute.</p>

<p><span class="SimpleMath">\(\bf{Theorem:}\)</span> Every element of <span class="SimpleMath">\(G\)</span> can be written as a finite product of disjoint wreath cycles in <span class="SimpleMath">\(P\)</span>. This decomposition is unique up to ordering of the factors. We call such a decomposition a <em>wreath cycle decomposition</em>.</p>

<p><a id="X7B9157FB8383F109" name="X7B9157FB8383F109"></a></p>

<h4>1.4 <span class="Heading">Sparse Wreath Cycle</span></h4>

<p>We use the notation from <a href="chap1_mj.html#X7DD31B407B9402A3"><span class="RefLink">1.2</span></a> in order to introduce the following concepts.</p>

<p>The main motivation for introducing the concept of <em>sparse wreath cycles</em> is the efficient computation of centralisers of wreath product elements. Simply put, we compute the centraliser of an arbitrary element <span class="SimpleMath">\(g \in P\)</span> in <span class="SimpleMath">\(G\)</span> by conjugating it to a restricted representative <span class="SimpleMath">\(h = g^c \in P\)</span> and computing the centraliser of <span class="SimpleMath">\(h\)</span> in <span class="SimpleMath">\(G\)</span>. The wreath cycle decomposition of the representative <span class="SimpleMath">\(h\)</span> consists only of sparse wreath cycles.</p>

<p>More information on <em>sparse wreath cycles</em> and centralisers of wreath product elements can be found in Chapter 5 in <a href="chapBib_mj.html#biBwpeConjugacy">[BNRW22]</a>.</p>

<p><span class="SimpleMath">\(\bf{Definition:}\)</span> We say that a wreath cycle <span class="SimpleMath">\(g = (g_1, \ldots, g_m; \pi) \in G\)</span> is a <em>sparse wreath cycle</em>, if there exists an <span class="SimpleMath">\(i_0\)</span> such that <span class="SimpleMath">\(g_i = 1\)</span> for all <span class="SimpleMath">\(i \neq i_0\)</span>.</p>

<p><span class="SimpleMath">\(\bf{Example:}\)</span> For example if we consider the wreath product <span class="SimpleMath">\( \textrm{Sym}(4) \wr \textrm{Sym}(5) \)</span>, the element</p>

<p class="center">\[
{\bf(} \;\; (),\, (1,2,3),\, (),\, (),\, ();\, (1,2,4) \;\; {\bf)}
\]</p>

<p>is a sparse wreath cycle, as well as the element</p>

<p class="center">\[
{\bf(} \;\; (),\, (),\, (1,3),\, (),\, ();\, () \;\; {\bf)} \;.
\]</p>

<p><span class="SimpleMath">\(\bf{Theorem:}\)</span> Every element <span class="SimpleMath">\(g \in P\)</span> can be conjugated by some <span class="SimpleMath">\(c \in K^m \times \langle 1_H \rangle \leq P\)</span> to an element <span class="SimpleMath">\(h = g^c \in P\)</span> such that the wreath cycle decomposition of <span class="SimpleMath">\(h\)</span> consists only of sparse wreath cycles.</p>

<p><a id="X85861B017AEEC50B" name="X85861B017AEEC50B"></a></p>

<h4>1.5 <span class="Heading">Example</span></h4>

<p>In this section we present an example session which demonstrates how we can access the generic representation of a wreath product.</p>

<p>First we construct the wreath product <span class="SimpleMath">\(G = \textrm{Alt}(5) \wr \textrm{Sym}(7)\)</span>. For this we use the native <strong class="pkg">GAP</strong> command <code class="code">WreathProduct</code> (see <a href="https://www.gap-system.org/Manuals/doc/ref/chap49_mj.html#X7DF2AEBC8518FFA4"><span class="RefLink">Reference: Wreath Products</span></a>). The resulting group is embedded into a symmetric group on <span class="SimpleMath">\(5 \cdot 7 = 35\)</span> points via the imprimitive action of the wreath product. The size of the group is</p>

<p class="center">\[
\vert G \vert = \vert\textrm{Alt}(5)\vert^7 \cdot \vert\textrm{Sym}(7)\vert = 60^7 \cdot 5\,040 = 14\,108\,774\,400\,000\,000\;.
\]</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K := AlternatingGroup(5);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := SymmetricGroup(7);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := WreathProduct(K, H);</span>
&lt;permutation group of size 14108774400000000 with 4 generators&gt;
</pre></div>

<p>Now we construct an isomorphism to a wreath product given in generic representation that is provided in <strong class="pkg">WPE</strong>. For this, we need to load the package.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage("WPE");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := IsomorphismToGenericWreathProduct(G);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W := Image(iso);</span>
&lt;group of size 14108774400000000 with 4 generators&gt;
</pre></div>

<p>Let us compare how <strong class="pkg">GAP</strong> displays elements in <span class="SimpleMath">\(G\)</span> and <span class="SimpleMath">\(W\)</span> respectively. Elements in <span class="SimpleMath">\(G\)</span> are represented as permutations. In this representation it is hard to see how the base and top components of this element look like.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := (1,13,3,14,4,12,2,15,5,11)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        (6,31,21,7,35,25,9,33,23,8,34,24,10,32,22)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        (18,19,20);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g in G;</span>
true
</pre></div>

<p>Elements in <span class="SimpleMath">\(W\)</span> however are represented as generic wreath product elements. (see <a href="chap1_mj.html#X7DD31B407B9402A3"><span class="RefLink">1.2</span></a>) This allows us to easily read off the base and top component of the element by either printing or displaying the element. Otherwise, by default the element is viewed in compressed form. (see <a href="chap3_mj.html#X8227AD6B7FC637DE"><span class="RefLink">3.4</span></a>) This printing behaviour is similar to matrices in <strong class="pkg">GAP</strong>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := g ^ iso;</span>
&lt; wreath product element with 7 base components &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print(x);</span>
( (1,3,4,2,5), (2,5)(3,4), (), (3,4,5), (1,2)(4,5), (), (); (1,3)(2,7,5) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(x);</span>
       1           2       3      4         5       6   7       top     
( (1,3,4,2,5), (2,5)(3,4), (), (3,4,5), (1,2)(4,5), (), (); (1,3)(2,7,5) )
</pre></div>

<p>Furthermore, we can display each component easily with the provided commands.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BaseComponentOfWreathProductElement(x, 2);</span>
(2,5)(3,4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TopComponentOfWreathProductElement(x);</span>
(1,3)(2,7,5)
</pre></div>

<p>Next, we compute the territory of <span class="SimpleMath">\(x\)</span>, i.e. the analogue of the support of a permutation.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Territory(x);</span>
[ 1, 2, 3, 4, 5, 7 ]
</pre></div>

<p>Finally, let us compute the disjoint wreath cycle decomposition of <span class="SimpleMath">\(x\)</span>, i.e. the analogue of the disjoint cycle decomposition of a permutation.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">wreathDecomp := WreathCycleDecomposition(x);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print(wreathDecomp);</span>
[ ( (), (), (), (3,4,5), (), (), (); () ), 
  ( (1,3,4,2,5), (), (), (), (), (), (); (1,3) ), 
  ( (), (2,5)(3,4), (), (), (1,2)(4,5), (), (); (2,7,5) ) ]
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
