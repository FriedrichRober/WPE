<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (WPE) - Chapter 1: Introduction</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap1"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap1_mj.html">[MathJax on]</a></p>
<p><a id="X7DFB63A97E67C0A1" name="X7DFB63A97E67C0A1"></a></p>
<div class="ChapSects"><a href="chap1.html#X7DFB63A97E67C0A1">1 <span class="Heading">Introduction</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X8389AD927B74BA4A">1.1 <span class="Heading">Overview</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7DD31B407B9402A3">1.2 <span class="Heading">Notation</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X867C059E7E460EFA">1.3 <span class="Heading">Wreath Cycle Decomposition</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X855D897C7E0D01C7">1.4 <span class="Heading">Sparse Wreath Cycle Decomposition</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X85861B017AEEC50B">1.5 <span class="Heading">Example</span></a>
</span>
</div>
</div>

<h3>1 <span class="Heading">Introduction</span></h3>

<p><a id="X8389AD927B74BA4A" name="X8389AD927B74BA4A"></a></p>

<h4>1.1 <span class="Heading">Overview</span></h4>

<p>This package is about wreath product elements in their general representation. This representation is more intuitive to the User when working with wreath products and additionally may have computational benefits over other representations.</p>

<p>[TODO:: Add references]</p>

<p><a id="X7DD31B407B9402A3" name="X7DD31B407B9402A3"></a></p>

<h4>1.2 <span class="Heading">Notation</span></h4>

<p>Let <span class="SimpleMath">G = K ≀ H</span> be a wreath product, where <span class="SimpleMath">H</span> is a permutation group of degree <span class="SimpleMath">m</span>. The wreath product is defined as the semidirect product of the function space <span class="SimpleMath">K^m</span> with <span class="SimpleMath">H</span>, where <span class="SimpleMath">π ∈ H</span> acts on <span class="SimpleMath">f ∈ K^m</span> by setting <span class="SimpleMath">f^{π} : {1, ..., m} → K, i ↦ [(i)π^{-1}]f</span>.</p>

<p>Formally we can write elements of <span class="SimpleMath">G</span> as a tuple <span class="SimpleMath">g = (f, π) ∈ G</span>, where <span class="SimpleMath">f ∈ K^m</span> is a function <span class="SimpleMath">f : {1, ..., m} → K</span> and <span class="SimpleMath">π ∈ H ≤ Sym(m)</span> is a permutation on <span class="SimpleMath">m</span> points. We call <span class="SimpleMath">f</span> the <em>base component</em> and <span class="SimpleMath">π</span> the <em>top component</em> of <span class="SimpleMath">g</span>.</p>

<p>We can naturally identify a map <span class="SimpleMath">f ∈ K^m</span> with a tuple <span class="SimpleMath">(g_1, ..., g_m)</span>, where each <span class="SimpleMath">g_i ∈ K</span> is the image of <span class="SimpleMath">i ∈ {1, ..., m}</span> under <span class="SimpleMath">f</span>. This yields a second useful notation for elements in <span class="SimpleMath">G</span> by writing <span class="SimpleMath">g = (g_1, ..., g_m; π)</span>. Note that we use a semicolon to seperate the base component from the top component. Further we call the element <span class="SimpleMath">g_i</span> the <em><span class="SimpleMath">i</span>-th base component</em> of <span class="SimpleMath">g</span>.</p>

<p><a id="X867C059E7E460EFA" name="X867C059E7E460EFA"></a></p>

<h4>1.3 <span class="Heading">Wreath Cycle Decomposition</span></h4>

<p>In a permutation group we have the well-known concept of a cycle decomposition. For wreath products we have a similar concept called <em>wreath cycle decomposition</em> that allows us to solve certain computational tasks more efficiently. First we introduce the concept of the territory. We define the <em>territory</em> of an element <span class="SimpleMath">g = (g_1, ..., g_m; π) ∈ G</span> by <span class="SimpleMath">terr(g) := supp(π) ∪ {i : g_i ≠ 1}</span>.</p>

<p>An element <span class="SimpleMath">g = (g_1, ..., g_m; π) ∈ G</span> is called a <em>wreath cycle</em> if either <span class="SimpleMath">π</span> is a cycle and <span class="SimpleMath">g_i = 1</span> for all <span class="SimpleMath">i ∈ fix(π)</span> or <span class="SimpleMath">|terr(g)| = 1</span>.</p>

<p>The idea is to write an arbitrary element of the wreath product <span class="SimpleMath">G = K ≀ H</span> as a product of disjoint wreath cycles as follows:</p>

<p>Decompose <span class="SimpleMath">π</span> into cycles, say <span class="SimpleMath">π = π_1 ... π_l</span>. For a set <span class="SimpleMath">I ≤ {1, ..., m}</span> we define <span class="SimpleMath">f_I</span> as an element of <span class="SimpleMath">K^m</span> by setting</p>


<ul>
<li><p><span class="SimpleMath">[i]f_I := g_i</span>, if <span class="SimpleMath">i ∈ I</span></p>

</li>
<li><p><span class="SimpleMath">[i]f_I := 1_K</span>, else</p>

</li>
</ul>
<p>For each cycle <span class="SimpleMath">π_r</span> we define <span class="SimpleMath">top_r := (f_{supp(π_r)}, π_r)</span>. For each point <span class="SimpleMath">i</span> such that <span class="SimpleMath">i not ∈ supp(π)</span> and <span class="SimpleMath">g_i ≠ 1_K</span> we define <span class="SimpleMath">base_i := (f_{i}, 1_H)</span>. Then <span class="SimpleMath">g</span> can be written as a product of the <span class="SimpleMath">top_r</span> and <span class="SimpleMath">base_i</span> elements and all those element are wreath cycles with pairwise disjoint territory. Thus in particular these elements commute pairwise.</p>

<p><a id="X855D897C7E0D01C7" name="X855D897C7E0D01C7"></a></p>

<h4>1.4 <span class="Heading">Sparse Wreath Cycle Decomposition</span></h4>

<p>The main motivation for introducing the concept of <em>sparse wreath cycles decompositions</em> is the efficient computation of centralisers of wreath product elements. Simply put, we compute the centraliser of an arbitrary element <span class="SimpleMath">g ∈ G</span> in <span class="SimpleMath">G</span> by conjugating it to a restricted representative <span class="SimpleMath">h = g^c ∈ G</span> and computing the centraliser of <span class="SimpleMath">h</span> in <span class="SimpleMath">G</span>.</p>

<p>We say that a wreath cycle <span class="SimpleMath">g = (g_1, ..., g_m; π) ∈ G</span> is a <em>sparse wreath cycle</em>, if there exists an <span class="SimpleMath">i_0</span> such that <span class="SimpleMath">g_i ≠ 1</span> for all <span class="SimpleMath">i ≠ i_0</span>.</p>

<p>We call a product of sparse wreath cycles a <em>sparse wreath cycle decomposition</em>. Every element <span class="SimpleMath">g ∈ G</span> can be conjugated by a base group element <span class="SimpleMath">c ∈ G</span> to an element <span class="SimpleMath">h = g^c ∈ G</span> that can be written in sparse wreath cycle decomposition as follows:</p>

<p>Suppose for an arbitrary element <span class="SimpleMath">g = (g_1, ..., g_m; π) ∈ G</span> we have a wreath cycle decomposition into cycles <span class="SimpleMath">w_1, ..., w_l ∈ G</span>. There exist pairwise disjoint base group elements <span class="SimpleMath">c_1, ..., c_l ∈ G</span> such that <span class="SimpleMath">w_k^{c_k}</span> is a sparse wreath cycle for all <span class="SimpleMath">k</span>. In particular the product of the sparse wreath cycles is the same as <span class="SimpleMath">g^{c_1 ⋯ c_l}</span> and the elements <span class="SimpleMath">c_k</span> commute pairwise.</p>

<p><a id="X85861B017AEEC50B" name="X85861B017AEEC50B"></a></p>

<h4>1.5 <span class="Heading">Example</span></h4>

<p>In this section we present an example session.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage("WPE");;</span>

# Construct an imprimitive wreath product
# that is embedded into a symmetric group.
# This is the native GAP wreath product command.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K := AlternatingGroup(5);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := SymmetricGroup(7);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := WreathProduct(K, H);</span>
&lt;permutation group of size 14108774400000000 with 4 generators&gt;

# Construct an isomorphism to the generic wreath product
# that is provided in this package.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := IsomorphismToGenericWreathProduct(G);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W := Image(iso);</span>
&lt;group of size 14108774400000000 with 4 generators&gt;

# Let us compare how GAP displays elements in G and W respectively.
# Elements in G are represented as permutations.
# In this representation it is completely unclear
# how the base and top components of this element look like.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := (1,23,33,27,9,13,2,25,34,28,8,14,3,24,35,30,10,12,5,21,32,29,6,11,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">4,22,31,26,7,15)(18,19,20);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g in G;</span>
true

# Elements in W are represented as generic wreath product elements
# that makes it easy to read off the base and top component of the element.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := g^iso;</span>
( (1,3,4,2,5), (2,5)(3,4), (1,4,3,2,5), (3,4,5), (1,2)(4,5), (1,2,4), 
(2,4,3); (1,5,7,6,2,3) )

# We can display each component easily with the provided commands.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BaseComponentOfWreathProductElement(x, 2);</span>
(2,5)(3,4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TopComponentOfWreathProductElement(x);</span>
(1,5,7,6,2,3)

# Let us decompose the element into disjoint wreath cycles.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">wreathDecomp := WreathCycleDecomposition(x);</span>
[ ( (), (), (), (3,4,5), (), (), (); () ), 
  ( (1,3,4,2,5), (2,5)(3,4), (1,4,3,2,5), (), (1,2)(4,5), (1,2,4), (2,4,3); 
    (1,5,7,6,2,3) ) ]

# Now we want to bring these cycles into sparse form.
# Each sparse wreath cycle is a very restricted element,
# since at most one entry in the base component is non-trivial.
# The product of these elements is a conjugate to x.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sparseDecomp := SparseWreathCycleDecomposition(x);</span>
[ ( (), (), (), (3,4,5), (), (), (); () ), 
  ( (1,2,3,5,4), (), (), (), (), (), (); (1,5,7,6,2,3) ) ]

# We can also compute the conjugating elements to switch between
# the wreath cycles and sparse wreath cycles.
# The product of these elements conjugates the wreath cycles
# simultaneously to the sparse wreath cycles.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">conj := ConjugatorWreathCycleToSparse(x);</span>
[ ( (), (), (), (), (), (), (); () ), ( (), (1,4,2), (1,4,3,2,5), (), 
    (1,4,5,3,2), (), (2,4,3); () ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">wreathDecomp[1]^conj[1] = sparseDecomp[1];</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">wreathDecomp[2]^conj[2] = sparseDecomp[2];</span>
true
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
